
;; fasm file-transfer.fasm && chmod +x file-transfer && ./file-transfer

; TODO
;
; non-blocking IO and check ret code

;; info
;;
;; registers:
;; rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14 (and more)
;;
;; syscall args go to:
;; arg0(syscall-number)=rax arg1=rdi arg2=rsi arg3=rdx arg4=r10 arg5=r8 arg6=r9
;;
;; (hepefully all) syscall return to `rax`
;;
;; db - byte - 1 byte
;; dw - word - 2 bytes
;; dd - double word - 4 bytes
;; dq - quad word - 8 bytes
;;
;; rax is 64bits
;; eax is 32bits
;; for more info see https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture

;; debug tips
;;
;; omg you get NO SYMBOLS WTF
;; no `main`, no `_start`, nothing
;;
;; run with `strace`
;;
;; `readelf -e <file>` and find the `entry point address`
;; then in `gdb <file>` put a breakpoint on that address `b *0x4000b0`
;; then `run` and `tui enable` and `layout asm`
;; and you will get an asm view
;;
;; less retarded debugger is `gf` executable is called `gf2` https://github.com/nakst/gf
;; again, break on the entry point using `b *0x4000b0`
;; switch to the `registers` tab
;; start with `run`
;; use `ni` for next step

format ELF64 executable

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: data types

1B equ db
2B equ dw
4B equ dd
8B equ dq

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: syscall ids
;; https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md

SYSCALL_READ equ 0
SYSCALL_WRITE equ 1
SYSCALL_CLOSE equ 3
SYSCALL_SOCKET equ 41
SYSCALL_ACCEPT equ 43
SYSCALL_SHUTDOWN equ 48
SYSCALL_BIND equ 49
SYSCALL_LISTEN equ 50
SYSCALL_SETSOCKOPT equ 54
SYSCALL_FORK equ 57
SYSCALL_EXIT equ 60

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: files

FILE_STDIN equ 0
FILE_STDOUT equ 1
FILE_STDERR equ 2

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: return codes

RET_CODE_SUCC equ 0
RET_CODE_FAIL equ 1
RET_CODE_TCP_SOCKET_FAIL equ 2
RET_CODE_BIND_FAIL equ 3
RET_CODE_LISTEN_FAIL equ 4
;RET_CODE_ACCEPT_FAIL equ 5 ; no longer used
RET_CODE_SETSOCKOPT_FAIL equ 6

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: sockets

SOCKET_DOMAIN_IPV4 equ 2
SOCKET_TYPE_TCP equ 1

SOL_SOCKET equ 1
SO_REUSEADDR equ 2
SO_REUSEPORT equ 15

SHUTDOWN_READ equ 0
SHUTDOWN_WRITE equ 1
SHUTDOWN_READ_AND_WRITE equ 2

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: server parameters

MAX_CONNECTIONS equ 5
SERVING_THREADS equ 20
URL_MAXLEN equ 128 ; in bytes
HEADER_LINE_MAXLEN equ 128 ; in bytes

;;;;;;;;;;;;;;;;;;;;;;;;; comptime constants: idkman

METHOD_GET equ 0
METHOD_POST equ 1

;;;;;;;;;;;;;;;;;;;;;;;;; comptime variables

;; TODO create lbl_id
;; then use lbl_id+=1 where called

;;;;;;;;;;;;;;;;;;;;;;;;; macros: syscalls: shorthands

macro sys0 syscall_id
{
    mov rax, syscall_id
    syscall
}

macro sys1 syscall_id, arg1
{
    mov rdi, arg1
    sys0 syscall_id
}

macro sys2 syscall_id, arg1, arg2
{
    mov rsi, arg2
    sys1 syscall_id, arg1
}


macro sys3 syscall_id, arg1, arg2, arg3
{
    mov rdx, arg3
    sys2 syscall_id, arg1, arg2
}

macro sys4 syscall_id, arg1, arg2, arg3, arg4
{
    mov r10, arg4
    sys3 syscall_id, arg1, arg2, arg3
}

macro sys5 syscall_id, arg1, arg2, arg3, arg4, arg5
{
    mov r8, arg5
    sys4 syscall_id, arg1, arg2, arg3, arg4
}

;;;;;;;;;;;;;;;;;;;;;;;;; macros: syscalls: generic

macro sys_exit ret_code {
    sys1 SYSCALL_EXIT, ret_code
}

macro sys_fork {
    sys0 SYSCALL_FORK
}

macro sys_read fd, buf, size {
    sys3 SYSCALL_READ, fd, buf, size
}

macro sys_setsockopt fd, level, optname, optval, optlen {
    sys5 SYSCALL_SETSOCKOPT, fd, level, optname, optval, optlen
}

macro sys_shutdown socket, how {
    sys2 SYSCALL_SHUTDOWN, socket, how
}

macro sys_write fd, msg, msg_len {
    sys3 SYSCALL_WRITE, fd, msg, msg_len
}

;;;;;;;;;;;;;;;;;;;;;;;;; macros: syscalls: networking

macro sys_accept sockfd, addr, addr_len {
    sys3 SYSCALL_ACCEPT, sockfd, addr, addr_len
}

macro sys_bind sockfd, addr, addr_len {
    sys3 SYSCALL_BIND, sockfd, addr, addr_len
}

macro sys_close fd {
    sys1 SYSCALL_CLOSE, fd
}

macro sys_listen sockfd, max_connections {
    sys2 SYSCALL_LISTEN, sockfd, max_connections
}

macro sys_socket domain, type, protocol {
    sys3 SYSCALL_SOCKET, domain, type, protocol
}

;;;;;;;;;;;;;;;;;;;;;;;;; macros: other

macro print msg, msg_len {
    sys_write FILE_STDOUT, msg, msg_len
    sys_write FILE_STDOUT, str_nl, str_nl_len
}

macro create_tcp_socket {
;; returns: dword eax: sockfd
    sys_socket SOCKET_DOMAIN_IPV4, SOCKET_TYPE_TCP, 0 ;; only one TCP protocol exists so the last arguments stays at 0
    cmp rax, 0
    jge tcp_socket_ok
        sys_exit RET_CODE_TCP_SOCKET_FAIL
    tcp_socket_ok: ;; TODO try and use `$` or something similar so that the macro can be used more than once
}

; macro are_strings_equal str1, len1, str2, len2, label_if_equal, label_if_not_equal {
;     mov dl, len1
;     mov dh, len2

;     cmp dl, dh
;     jne label_if_not_equal

;     mov rax, str1
;     mov rbx, str2

;     string_compare_loop: ; TODO see https://board.flatassembler.net/topic.php?t=7344

;         cmp dl, 0
;         je label_if_equal

;         mov cl, [rax]
;         inc rax

;         mov ch, [rbx]
;         inc rbx

;         cmp cl, ch
;         jne label_if_not_equal

;         dec dl

;     jmp string_compare_loop
; }

;;;;;;;;;;;;;;;;;;;;;;;;; code section

segment readable executable

entry main

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

main:
    print str_starting_program, str_starting_program_len

    create_tcp_socket
    ;; returns: dword eax: sockfd

    mov qword [sockfd], rax

    sys_setsockopt [sockfd], SOL_SOCKET, SO_REUSEPORT, one, sizeof_one
    cmp rax, 0
    jge setsockopt_ok
        sys_exit RET_CODE_SETSOCKOPT_FAIL
    setsockopt_ok:

    ;; servaddr.sin_family = AF_INET;
    mov word [servaddr.sin_family], SOCKET_DOMAIN_IPV4

    ;; servaddr.sin_port = htons(PORT);
    ;;
    ;; convert endianness by hand
    ;; 6969 -(to-hex)-> 0x1b39 -(convert-endianness)-> 0x391b -(to-dec)-> 14619
    mov word [servaddr.sin_port], 14619
    ;;mov word [servaddr.sin_port], 14875

    ;; servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    ;; INADDR_ANY is 0 therefore I give 0 fucks about endianness
    mov dword [servaddr.sin_addr], 0

    sys_bind [sockfd], servaddr, servaddr.size
    cmp rax, 0
    jz bind_is_ok
        sys_exit RET_CODE_BIND_FAIL
    bind_is_ok:

    sys_listen [sockfd], MAX_CONNECTIONS
    cmp rax, 0
    jz listen_is_ok ;; ЛИСТЕН ЛИСТЕН
        sys_exit RET_CODE_LISTEN_FAIL
    listen_is_ok:

    rept SERVING_THREADS counter {
        sys_fork
        cmp rax, 0
        jnz is_parent_#counter
            ;; is child
            jmp serving_thread
        is_parent_#counter:
    }

    bullshit:
    jmp bullshit

    sys_shutdown [sockfd], SHUTDOWN_READ_AND_WRITE
    sys_close [sockfd]

    sys_exit RET_CODE_SUCC

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

serving_thread:

    sys_accept [sockfd], cliaddr, cliaddr_size
    cmp rax, 0
    jg accept_is_ok
        ;; client is a piece of shit
        jmp serving_thread
    accept_is_ok:

    mov qword [connfd], rax

    call receive_header

    sys_shutdown [connfd], SHUTDOWN_READ_AND_WRITE
    sys_close [connfd]

    jmp serving_thread

    sys_exit RET_CODE_SUCC

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

receive_header:

    sys_read [connfd], tmp_4B, tmp_4B.size

    ; print tmp_4B, tmp_4B.size

    cmp [tmp_4B], 'G'
    je method_get ; assume GET
    jmp method_post ; assume POST

    method_get:
        mov [method], METHOD_GET
        jmp method_finished

    method_post:
        sys_read [connfd], tmp_1B, tmp_1B.size ; get rid of ` `
        mov [method], METHOD_POST
        jmp method_finished

    method_finished:

    mov rcx, url
    mov [url.len], 0

    receive_next_byte_from_url:
        push rcx ; TODO stupid
        sys_read [connfd], tmp_1B, tmp_1B.size
        pop rcx
        cmp [tmp_1B], ' '
        je url_received

        mov al, [tmp_1B]
        mov [rcx], al

        inc rcx
        inc [url.len]

        cmp [url.len], URL_MAXLEN
        je receive_header_return ; url is too long, abandon ship

        jmp receive_next_byte_from_url
    url_received:

    mov rdx, 0
    mov dl, [url.len]
    print url, rdx

    call read_rest_of_header

    call handle_request

    receive_header_return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

read_rest_of_header:

    .read_next_line:

        call read_next_header_line

        mov rdx, 0
        mov dl, [header_line.len]
        print header_line, rdx

        cmp [header_line.len], 0
        je .return

    jmp .read_next_line
    
    .return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

; save_header_line_content_type_boundary:
;     save_header_line_content_type_boundary.begin_again:

;     call read_next_header_line

;     cmp [header_line.len], 0
;     je save_header_line_content_type_boundary.ret

;     are_strings_equal \
;         str_header_line_content_type_containing_boundary, \
;         str_header_line_content_type_containing_boundary.size, \
;         header_line, \
;         str_header_line_content_type_containing_boundary.size, \
;         save_header_line_content_type_boundary.found, \
;         save_header_line_content_type_boundary.begin_again

;     save_header_line_content_type_boundary.found:

;     ; mov rax, header_line
;     ; add rax, str_header_line_content_type_containing_boundary.size

;     ; mov bl, [header_line.len]
;     ; sub bl, str_header_line_content_type_containing_boundary.size

;     ; mov bh, bl ; save length for later

;     ; mov rcx, multipart_boundary

;     ; ; TODO now copy the rest to the `multipart_boundary` buf
;     ; save_header_line_content_type_boundary.copy_loop:
;     ;     cmp bl, 0
;     ;     je .copy_done ; TODO hopefully this work as a local label

;     ;     mov bh, [rax] ; read byte to bh
;     ;     inc rax

;     ;     mov [rdx], bh ; put byte in `multipart_boundary`
;     ;     inc rdx

;     ;     dec bl
    
;     ;     jmp save_header_line_content_type_boundary.copy_loop
;     ; .copy_done:

;     ; mov [multipart_boundary.len], bh

;     save_header_line_content_type_boundary.ret:
;     ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

read_next_header_line:
    
    mov rax, header_line
    push rax

    mov [header_line.len], 0

    sys_read [connfd], tmp_1B_a, tmp_1B_a.size
    
    read_next_header_line.loop:

        sys_read [connfd], tmp_1B_b, tmp_1B_b.size

        cmp [tmp_1B_b], 10 ; \n
        jne read_next_header_line.read_next_byte
        cmp [tmp_1B_a], 13 ; \r
        jne read_next_header_line.read_next_byte

        jmp read_next_header_line.line_done

        read_next_header_line.read_next_byte:

        pop rax
        mov cl, [tmp_1B_a]
        mov [rax], cl
        inc rax
        push rax

        inc [header_line.len]

        cmp [header_line.len], HEADER_LINE_MAXLEN
        je read_next_header_line.line_done ; TODO ideally we would discard the rest of the line

        mov al, [tmp_1B_b]
        mov [tmp_1B_a], al

        jmp read_next_header_line.loop
    
    read_next_header_line.line_done:

    pop rax

    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_request:

    call send_http_headers

    cmp [url.len], 2
    je requested_page_download

    cmp [url.len], 3
    je requested_page_upload

    cmp [url.len], 4
    je requested_script_file_upload

    jmp requested_page_main

    requested_page_main:
        call handle_page_main
        jmp handle_request_return

    requested_page_download:
        call handle_page_download
        jmp handle_request_return

    requested_page_upload:
        call handle_page_upload
        jmp handle_request_return

    handle_request_return:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

send_http_headers:
    sys_write [connfd], str_http_headers, str_http_headers.size
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_page_main:
    sys_write [connfd], str_html_page_main, str_html_page_main.size
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_page_download:
    sys_write [connfd], str_html_page_download, str_html_page_download.size
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

handle_page_upload:
    sys_write [connfd], str_html_page_upload, str_html_page_upload.size
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; fnc

requested_script_file_upload:
    ret

;;;;;;;;;;;;;;;;;;;;;;;;; data section

segment readable writable

;;;;;;;;;;;;;; "generic" data

str_nl db 10 ;; new line character
str_nl_len = $ - str_nl

one 4B 1
sizeof_one = $ - one

tmp_1B 1B 0
tmp_1B.size = $ - tmp_1B

tmp_1B_a 1B 0
tmp_1B_a.size = $ - tmp_1B_a

tmp_1B_b 1B 0
tmp_1B_b.size = $ - tmp_1B_b

tmp_4B 1B 0,0,0,0
tmp_4B.size = $ - tmp_4B

;;;;;;;;;;;;;; other data

;;;;;;;; strings

str_starting_program db "starting program"
str_starting_program_len = $ - str_starting_program

;;str_creating_socket db "creating socket"
;;str_creating_socket_len = $ - str_creating_socket

str_http_headers db "HTTP/1.1 200 OK", 13, 10
                 db "Content-Type: text/html; charset=utf-8", 13, 10
                 db "Connection: close", 13, 10
                 db 13, 10
str_http_headers.size = $ - str_http_headers

; str_html_page_main db "<h1>Hello from flat asm</h1>", 10
str_html_page_main db "<!DOCTYPE html>", 10
                   db "<html>", 10
                   db "  <head>", 10
                   db "    <title>asdasdsdafcstgcreztre</title>", 10
                   db "  </head>", 10
                   db "  <body>", 10
                   db '    <a href="/u" target="_blank">file upload</a>', 10
                   db "    <br>", 10
                   db '    <a href="/dw" target="_blank">file download</a>', 10
                   db "  </body>", 10
                   db "</html>", 10
str_html_page_main.size = $ - str_html_page_main

; str_html_page_download db "<h1>download page</h1>", 10
str_html_page_download db "<!DOCTYPE html>", 10
    db "<html>", 10
    db '<form action="/sup" method="post" enctype="multipart/form-data">', 10
    db '  <label for="file">File</label>', 10
    db '  <input id="file" name="file" type="file" />', 10
    db "  <button>Upload</button>", 10
    db "</form>", 10
    db "</html>", 10
str_html_page_download.size = $ - str_html_page_download

; str_html_page_upload db "<h1>upload page</h1>", 10
str_html_page_upload db "<!DOCTYPE html>", 10    
    db "<html>", 10
    db '<form action="/script_file_download" method="post">', 10
    db "  <button>Click to download</button>", 10
    db "</form>", 10
    db "</html>", 10
str_html_page_upload.size = $ - str_html_page_upload

str_header_line_multipart_boundary db "Content-Type: multipart/form-data; boundary="
str_header_line_multipart_boundary.size = $ - str_header_line_multipart_boundary

;;;;;;;; other

;; struct sockaddr_in {
;;     sa_family_t    sin_family;  // 16 bits
;;     in_port_t      sin_port;    // 16 bits
;;     struct in_addr sin_addr;    // 32 bits
;;     uint8_t        sin_zero[8]; // 64 bits
;; }
;;
struc servaddr_in
{
    .sin_family dw 0
    .sin_port   dd 0
    .sin_addr   dd 0
    .sin_zero   dq 0
    .size = $ - .sin_family ;; this should be a comptime variable
}

sockfd dq -1

connfd dq -1

servaddr servaddr_in ;; OMT tova e kato `equ` i `=` (note that moje da dava6 parametri na taq struktura)

cliaddr servaddr_in
cliaddr_size dd servaddr.size

method 1B 0


header_line 1B 0
rept (HEADER_LINE_MAXLEN-1) {
       1B 0
}
header_line.len 1B 0

url 1B 0
rept (URL_MAXLEN-1) {
       1B 0
}
url.len 1B 0

multipart_boundary 1B 0
rept (HEADER_LINE_MAXLEN-1) {
    1B 0
}
multipart_boundary.len 1B 0
